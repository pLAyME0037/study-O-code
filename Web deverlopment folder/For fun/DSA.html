<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DSA Learning Hub</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            display: flex;
            flex-direction: column;
            min-height: 100vh;
            background-color: #f3f4f6; /* Tailwind gray-100 */
        }
        .sidebar {
            width: 280px; /* Fixed width for sidebar */
            background-color: #1f2937; /* Tailwind gray-800 */
            color: #d1d5db; /* Tailwind gray-300 */
            padding: 20px;
            height: 100vh; /* Full height */
            position: fixed;
            top: 0;
            left: 0;
            overflow-y: auto;
            transition: transform 0.3s ease-in-out;
        }
        .sidebar-hidden {
            transform: translateX(-100%);
        }
        .main-content {
            margin-left: 280px; /* Same as sidebar width */
            padding: 20px;
            flex-grow: 1;
            transition: margin-left 0.3s ease-in-out;
        }
        .main-content-full {
            margin-left: 0;
        }
        .content-section {
            display: none;
        }
        .content-section.active {
            display: block;
        }
        .terminal {
            background-color: #111827; /* Tailwind gray-900 */
            color: #9ca3af; /* Tailwind gray-400 */
            padding: 15px;
            border-radius: 8px;
            font-family: 'Menlo', 'Monaco', 'Courier New', monospace;
            font-size: 0.875rem;
            line-height: 1.5;
            margin-top: 20px;
            height: 300px;
            overflow-y: auto;
            border: 1px solid #374151; /* Tailwind gray-700 */
        }
        .terminal-output {
            white-space: pre-wrap;
        }
        .terminal-prompt {
            color: #34d399; /* Tailwind green-400 */
        }
        .code-block {
            background-color: #1f2937; /* Tailwind gray-800 */
            color: #e5e7eb; /* Tailwind gray-200 */
            padding: 15px;
            border-radius: 8px;
            margin: 15px 0;
            overflow-x: auto;
            font-family: 'Menlo', 'Monaco', 'Courier New', monospace;
        }
        .menu-button {
            display: none; /* Hidden on larger screens */
            position: fixed;
            top: 10px;
            left: 10px;
            z-index: 1000;
            background-color: #1f2937;
            color: white;
            padding: 8px;
            border-radius: 5px;
        }
        @media (max-width: 768px) {
            .sidebar {
                transform: translateX(-100%);
                z-index: 999;
            }
            .sidebar-visible {
                transform: translateX(0);
            }
            .main-content {
                margin-left: 0;
            }
            .menu-button {
                display: block;
            }
        }

        /* Custom scrollbar for terminal and sidebar */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }
        ::-webkit-scrollbar-track {
            background: #1f2937; /* Darker background for track */
        }
        ::-webkit-scrollbar-thumb {
            background: #4b5563; /* Tailwind gray-600 */
            border-radius: 4px;
        }
        ::-webkit-scrollbar-thumb:hover {
            background: #6b7280; /* Tailwind gray-500 */
        }
        .terminal::-webkit-scrollbar-track {
            background: #111827; /* Terminal bg for its scrollbar track */
        }
    </style>
</head>
<body>

    <button id="menuButton" class="menu-button md:hidden">
        <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-6 h-6">
            <path stroke-linecap="round" stroke-linejoin="round" d="M3.75 6.75h16.5M3.75 12h16.5m-16.5 5.25h16.5" />
        </svg>
    </button>

    <nav id="sidebar" class="sidebar">
        <h1 class="text-2xl font-bold text-white mb-6 border-b border-gray-700 pb-3">DSA Hub</h1>
        <ul id="topicList" class="space-y-2">
            </ul>
    </nav>

    <main id="mainContent" class="main-content">
        <div id="pageContent">
            </div>

        <div class="mt-8">
            <div class="flex justify-between items-center mb-2">
                <h2 class="text-xl font-semibold text-gray-700">Interactive Terminal</h2>
                <button id="clearTerminalButton" class="px-4 py-2 bg-red-500 text-white rounded-lg hover:bg-red-600 text-sm">Clear Terminal</button>
            </div>
            <div id="terminal" class="terminal">
                <div id="terminalOutput" class="terminal-output">
                    Welcome to the Interactive DSA Terminal!
                    <br>Run code examples to see their output here.
                </div>
            </div>
        </div>
    </main>

    <script>
        // Data for the DSA course
        const dsaCourse = [
            {
                id: 'intro',
                title: 'Introduction to DSA',
                content: `
                    <h2 class="text-3xl font-bold mb-4 text-gray-800">Welcome to Data Structures & Algorithms!</h2>
                    <p class="mb-4 text-gray-700 leading-relaxed">
                        Data Structures and Algorithms (DSA) are fundamental building blocks in computer science and software development.
                        Understanding them is crucial for writing efficient, scalable, and maintainable code.
                    </p>
                    <h3 class="text-2xl font-semibold mb-3 text-gray-800">What are Data Structures?</h3>
                    <p class="mb-4 text-gray-700 leading-relaxed">
                        A data structure is a specialized format for organizing, processing, retrieving, and storing data.
                        There are several basic and advanced types of data structures, all designed to arrange data to suit a specific purpose.
                        Examples include arrays, linked lists, stacks, queues, trees, graphs, etc.
                        Choosing the right data structure can significantly impact the performance of your program.
                    </p>
                    <h3 class="text-2xl font-semibold mb-3 text-gray-800">What are Algorithms?</h3>
                    <p class="mb-4 text-gray-700 leading-relaxed">
                        An algorithm is a finite sequence of well-defined, computer-implementable instructions, typically to solve a class of specific problems or to perform a computation.
                        Algorithms are used in conjunction with data structures to manipulate the data they store.
                        Examples include sorting algorithms (like Bubble Sort, Merge Sort), searching algorithms (like Linear Search, Binary Search), graph traversal algorithms, etc.
                    </p>
                    <h3 class="text-2xl font-semibold mb-3 text-gray-800">Why is DSA Important?</h3>
                    <ul class="list-disc list-inside mb-4 text-gray-700 leading-relaxed space-y-1">
                        <li><strong>Efficiency:</strong> Proper choice of DSA leads to faster and more memory-efficient programs.</li>
                        <li><strong>Problem Solving:</strong> DSA provides tools and techniques to solve complex computational problems effectively.</li>
                        <li><strong>Scalability:</strong> Well-designed algorithms and data structures help in building systems that can handle large amounts of data and traffic.</li>
                        <li><strong>Interview Preparation:</strong> DSA is a core topic in technical interviews for software engineering roles.</li>
                    </ul>
                    <h3 class="text-2xl font-semibold mb-3 text-gray-800">Understanding Algorithmic Complexity (Big O Notation)</h3>
                    <p class="mb-4 text-gray-700 leading-relaxed">
                        Big O notation is a mathematical notation that describes the limiting behavior of a function when the argument tends towards a particular value or infinity. In computer science, it's used to classify algorithms according to how their run time or space requirements grow as the input size grows.
                    </p>
                    <p class="mb-2 text-gray-700">Common Big O complexities (from best to worst):</p>
                    <ul class="list-disc list-inside mb-4 text-gray-700 leading-relaxed space-y-1">
                        <li><strong>O(1) - Constant Time:</strong> The algorithm takes the same amount of time, regardless of the input size. Example: Accessing an array element by its index.</li>
                        <li><strong>O(log n) - Logarithmic Time:</strong> The time taken increases logarithmically with the input size. Example: Binary search.</li>
                        <li><strong>O(n) - Linear Time:</strong> The time taken increases linearly with the input size. Example: Traversing an array or linked list.</li>
                        <li><strong>O(n log n) - Linearithmic Time:</strong> Common for efficient sorting algorithms like Merge Sort or Quick Sort.</li>
                        <li><strong>O(n<sup>2</sup>) - Quadratic Time:</strong> The time taken increases quadratically with the input size. Example: Bubble Sort, Selection Sort (naive implementations).</li>
                        <li><strong>O(2<sup>n</sup>) - Exponential Time:</strong> The time taken doubles with each addition to the input data set. Very slow for large inputs. Example: Recursive calculation of Fibonacci numbers (naive).</li>
                        <li><strong>O(n!) - Factorial Time:</strong> The time taken grows factorially. Extremely slow. Example: Traveling Salesperson Problem (brute-force).</li>
                    </ul>
                    <p class="text-gray-700 leading-relaxed">
                        When analyzing an algorithm, we usually care about the <strong>worst-case scenario</strong>, but sometimes average-case or best-case scenarios are also considered.
                        The goal is generally to find or design algorithms with the lowest possible Big O complexity for a given problem.
                    </p>
                `,
                codeExamples: []
            },
            {
                id: 'arrays',
                title: 'Arrays',
                content: `
                    <h2 class="text-3xl font-bold mb-4 text-gray-800">Arrays</h2>
                    <p class="mb-4 text-gray-700 leading-relaxed">
                        An array is a data structure consisting of a collection of elements (values or variables), each identified by at least one array index or key.
                        Arrays store elements of the same data type in contiguous memory locations. This allows for efficient access to elements using their index.
                    </p>
                    <h3 class="text-2xl font-semibold mb-3 text-gray-800">Key Characteristics:</h3>
                    <ul class="list-disc list-inside mb-4 text-gray-700 leading-relaxed space-y-1">
                        <li><strong>Fixed Size (in some languages):</strong> In languages like Java or C++, arrays typically have a fixed size defined at creation. JavaScript arrays are dynamic and can grow or shrink.</li>
                        <li><strong>Indexed Access:</strong> Elements are accessed via an integer index, usually starting from 0. Accessing an element by index is very fast (O(1)).</li>
                        <li><strong>Homogeneous Elements (typically):</strong> Arrays traditionally store elements of the same type, though JavaScript arrays are flexible and can store mixed types.</li>
                        <li><strong>Contiguous Memory:</strong> Elements are stored next to each other in memory, which can be beneficial for cache performance.</li>
                    </ul>
                    <h3 class="text-2xl font-semibold mb-3 text-gray-800">Common Operations:</h3>
                    <ul class="list-disc list-inside mb-4 text-gray-700 leading-relaxed space-y-1">
                        <li><strong>Accessing:</strong> Reading the value at a given index (O(1)).</li>
                        <li><strong>Searching:</strong> Finding an element in the array. Linear search is O(n), binary search (on sorted arrays) is O(log n).</li>
                        <li><strong>Insertion:</strong> Adding an element. Can be O(n) if elements need to be shifted (e.g., inserting at the beginning or middle). Appending to the end is often O(1) (amortized for dynamic arrays).</li>
                        <li><strong>Deletion:</strong> Removing an element. Can be O(n) if elements need to be shifted.</li>
                        <li><strong>Traversal:</strong> Visiting each element in the array (O(n)).</li>
                    </ul>
                    <h3 class="text-2xl font-semibold mb-3 text-gray-800">Pros:</h3>
                    <ul class="list-disc list-inside mb-4 text-gray-700 leading-relaxed space-y-1">
                        <li>Fast random access (O(1)).</li>
                        <li>Simple to use and understand.</li>
                        <li>Good memory locality.</li>
                    </ul>
                    <h3 class="text-2xl font-semibold mb-3 text-gray-800">Cons:</h3>
                    <ul class="list-disc list-inside mb-4 text-gray-700 leading-relaxed space-y-1">
                        <li>Fixed size in many statically-typed languages (JavaScript arrays are dynamic).</li>
                        <li>Costly insertions and deletions in the middle (O(n)).</li>
                        <li>Can lead to wasted memory if not fully utilized, or require resizing if capacity is exceeded (for dynamic arrays, resizing can be O(n)).</li>
                    </ul>
                `,
                codeExamples: [
                    {
                        description: 'Creating an array and accessing elements:',
                        code: `const numbers = [10, 20, 30, 40, 50];\nconsole.log("Array:", numbers);\nconsole.log("First element:", numbers[0]); // Output: 10\nconsole.log("Third element:", numbers[2]); // Output: 30\nconsole.log("Length of array:", numbers.length); // Output: 5`
                    },
                    {
                        description: 'Modifying an array element:',
                        code: `const colors = ["Red", "Green", "Blue"];\nconsole.log("Original colors:", colors);\ncolors[1] = "Yellow"; // Modify the second element\nconsole.log("Modified colors:", colors);`
                    },
                    {
                        description: 'Adding elements (push, unshift):',
                        code: `const fruits = ["Apple", "Banana"];\nconsole.log("Initial fruits:", fruits);\nfruits.push("Cherry"); // Adds to the end\nconsole.log("After push('Cherry'):", fruits);\nfruits.unshift("Mango"); // Adds to the beginning\nconsole.log("After unshift('Mango'):", fruits);`
                    },
                    {
                        description: 'Removing elements (pop, shift):',
                        code: `let animals = ["Dog", "Cat", "Elephant", "Lion"];\nconsole.log("Initial animals:", animals);\nlet removedLast = animals.pop(); // Removes from the end\nconsole.log("Removed last:", removedLast, "Remaining:", animals);\nlet removedFirst = animals.shift(); // Removes from the beginning\nconsole.log("Removed first:", removedFirst, "Remaining:", animals);`
                    },
                    {
                        description: 'Iterating through an array:',
                        code: `const scores = [90, 85, 92, 78];\nconsole.log("Scores:");\nfor (let i = 0; i < scores.length; i++) {\n  console.log(\`Score at index \${i}: \${scores[i]}\`);\n}\n\nconsole.log("\\nUsing for...of loop:");\nfor (const score of scores) {\n  console.log(score);\n}\n\nconsole.log("\\nUsing forEach method:");\nscores.forEach((score, index) => {\n  console.log(\`Score \${score} at index \${index}\`);\n});`
                    }
                ]
            },
            {
                id: 'linkedlists',
                title: 'Linked Lists',
                content: `
                    <h2 class="text-3xl font-bold mb-4 text-gray-800">Linked Lists</h2>
                    <p class="mb-4 text-gray-700 leading-relaxed">
                        A linked list is a linear data structure where elements are not stored at contiguous memory locations. Instead, elements are linked using pointers.
                        Each element, called a "node", consists of two parts:
                        <ol class="list-decimal list-inside ml-4 mb-2">
                            <li><strong>Data:</strong> The actual value stored in the node.</li>
                            <li><strong>Next Pointer (or Link):</strong> A reference to the next node in the sequence. The last node's next pointer typically points to null, indicating the end of the list.</li>
                        </ol>
                    </p>
                    <p class="mb-4 text-gray-700 leading-relaxed">The entry point to a linked list is called the "head", which is a pointer to the first node.</p>

                    <h3 class="text-2xl font-semibold mb-3 text-gray-800">Types of Linked Lists:</h3>
                    <ul class="list-disc list-inside mb-4 text-gray-700 leading-relaxed space-y-1">
                        <li><strong>Singly Linked List:</strong> Each node points only to the next node in the list. Traversal is unidirectional.</li>
                        <li><strong>Doubly Linked List:</strong> Each node has two pointers: one to the next node and one to the previous node. Traversal can be bidirectional.</li>
                        <li><strong>Circular Linked List:</strong> The last node's next pointer points back to the first node (or head), forming a circle. Can be singly or doubly circular.</li>
                    </ul>
                    <p class="mb-4 text-gray-700 leading-relaxed">This section will focus on <strong>Singly Linked Lists</strong>.</p>

                    <h3 class="text-2xl font-semibold mb-3 text-gray-800">Singly Linked List Node:</h3>
                    <pre class="code-block"><code>class Node {
    constructor(data) {
        this.data = data;
        this.next = null;
    }
}</code></pre>

                    <h3 class="text-2xl font-semibold mb-3 text-gray-800">Common Operations (Singly Linked List):</h3>
                    <ul class="list-disc list-inside mb-4 text-gray-700 leading-relaxed space-y-1">
                        <li><strong>Traversal:</strong> Visiting each node (O(n)). Start from the head and follow 'next' pointers.</li>
                        <li><strong>Insertion:</strong>
                            <ul class="list-disc list-inside ml-6">
                                <li>At the beginning (prepend): O(1) - Create new node, point its 'next' to current head, update head.</li>
                                <li>At the end (append): O(n) without a tail pointer, O(1) with a tail pointer - Traverse to last node (or use tail), update its 'next'.</li>
                                <li>At a specific position: O(n) - Traverse to the node before the desired position.</li>
                            </ul>
                        </li>
                        <li><strong>Deletion:</strong>
                            <ul class="list-disc list-inside ml-6">
                                <li>From the beginning: O(1) - Update head to head.next.</li>
                                <li>From the end: O(n) - Traverse to the second-to-last node.</li>
                                <li>At a specific position: O(n) - Traverse to the node before the one to be deleted.</li>
                            </ul>
                        </li>
                        <li><strong>Search:</strong> Finding a node with a specific value (O(n)) - Traverse and compare.</li>
                    </ul>

                    <h3 class="text-2xl font-semibold mb-3 text-gray-800">Pros:</h3>
                    <ul class="list-disc list-inside mb-4 text-gray-700 leading-relaxed space-y-1">
                        <li><strong>Dynamic Size:</strong> Can easily grow or shrink during runtime.</li>
                        <li><strong>Efficient Insertions/Deletions:</strong> Insertions and deletions (especially at the beginning or if pointer to previous node is known) can be very efficient (O(1)) compared to arrays, as no element shifting is needed.</li>
                        <li>Memory is allocated as needed, reducing waste.</li>
                    </ul>
                    <h3 class="text-2xl font-semibold mb-3 text-gray-800">Cons:</h3>
                    <ul class="list-disc list-inside mb-4 text-gray-700 leading-relaxed space-y-1">
                        <li><strong>No Random Access:</strong> Elements cannot be accessed directly by index (O(n) to reach an element).</li>
                        <li><strong>Extra Memory for Pointers:</strong> Each node requires extra space for the 'next' pointer (and 'previous' pointer in doubly linked lists).</li>
                        <li>Cache performance can be worse than arrays due to non-contiguous memory allocation.</li>
                    </ul>
                `,
                codeExamples: [
                    {
                        description: 'Creating a simple Singly Linked List and traversing it:',
                        code: `
class Node {
    constructor(data) {
        this.data = data;
        this.next = null;
    }
}

class LinkedList {
    constructor() {
        this.head = null;
    }

    // Add to the end of the list
    append(data) {
        const newNode = new Node(data);
        if (!this.head) {
            this.head = newNode;
            return;
        }
        let current = this.head;
        while (current.next) {
            current = current.next;
        }
        current.next = newNode;
    }

    // Print all nodes in the list
    printList() {
        let current = this.head;
        const elements = [];
        while (current) {
            elements.push(current.data);
            current = current.next;
        }
        console.log(elements.join(" -> "));
    }
}

const list = new LinkedList();
list.append(10);
list.append(20);
list.append(30);
console.log("Linked List:");
list.printList(); // Output: 10 -> 20 -> 30

list.append(40);
console.log("After appending 40:");
list.printList(); // Output: 10 -> 20 -> 30 -> 40
                        `
                    },
                    {
                        description: 'Prepending (adding to the beginning) to a Singly Linked List:',
                        code: `
class Node {
    constructor(data) {
        this.data = data;
        this.next = null;
    }
}

class LinkedList {
    constructor() {
        this.head = null;
    }

    append(data) { // Same as previous example
        const newNode = new Node(data);
        if (!this.head) { this.head = newNode; return; }
        let current = this.head;
        while (current.next) { current = current.next; }
        current.next = newNode;
    }
    
    prepend(data) {
        const newNode = new Node(data);
        newNode.next = this.head;
        this.head = newNode;
    }

    printList() { // Same as previous example
        let current = this.head; const elements = [];
        while (current) { elements.push(current.data); current = current.next; }
        console.log(elements.join(" -> "));
    }
}

const list = new LinkedList();
list.append(100);
list.append(200);
console.log("Initial list:");
list.printList(); // Output: 100 -> 200

list.prepend(50);
console.log("After prepending 50:");
list.printList(); // Output: 50 -> 100 -> 200
                        `
                    }
                ]
            },
            // Add more topics like Stacks, Queues, Sorting, Searching here
            {
                id: 'stacks',
                title: 'Stacks',
                content: `
                    <h2 class="text-3xl font-bold mb-4 text-gray-800">Stacks</h2>
                    <p class="mb-4 text-gray-700 leading-relaxed">
                        A stack is a linear data structure that follows the <strong>LIFO (Last-In, First-Out)</strong> principle. This means the last element added to the stack is the first one to be removed.
                        Think of a stack of plates: you add a plate to the top, and you remove a plate from the top.
                    </p>
                    <h3 class="text-2xl font-semibold mb-3 text-gray-800">Core Operations:</h3>
                    <ul class="list-disc list-inside mb-4 text-gray-700 leading-relaxed space-y-1">
                        <li><strong>Push:</strong> Adds an element to the top of the stack. (O(1))</li>
                        <li><strong>Pop:</strong> Removes and returns the element from the top of the stack. (O(1))</li>
                        <li><strong>Peek (or Top):</strong> Returns the element at the top of the stack without removing it. (O(1))</li>
                        <li><strong>isEmpty:</strong> Checks if the stack is empty. (O(1))</li>
                        <li><strong>isFull (for array-based fixed-size stacks):</strong> Checks if the stack is full. (O(1))</li>
                        <li><strong>Size:</strong> Returns the number of elements in the stack. (O(1))</li>
                    </ul>
                    <h3 class="text-2xl font-semibold mb-3 text-gray-800">Implementations:</h3>
                    <p class="mb-4 text-gray-700 leading-relaxed">
                        Stacks can be implemented using:
                        <ul class="list-disc list-inside ml-4">
                            <li><strong>Arrays (or Dynamic Arrays/Lists):</strong> Simple to implement. Push can be adding to the end, pop removing from the end.</li>
                            <li><strong>Linked Lists:</strong> Push can be prepending to the list, pop can be removing from the beginning.</li>
                        </ul>
                    </p>
                    <h3 class="text-2xl font-semibold mb-3 text-gray-800">Applications:</h3>
                    <ul class="list-disc list-inside mb-4 text-gray-700 leading-relaxed space-y-1">
                        <li>Function call management (call stack).</li>
                        <li>Undo/Redo functionality in software.</li>
                        <li>Expression evaluation (e.g., converting infix to postfix, evaluating postfix).</li>
                        <li>Backtracking algorithms (e.g., maze solving, N-Queens problem).</li>
                        <li>Browser history (navigating back).</li>
                        <li>Syntax parsing.</li>
                    </ul>
                `,
                codeExamples: [
                    {
                        description: 'Stack implementation using an Array:',
                        code: `
class Stack {
    constructor() {
        this.items = [];
    }

    // Add element to top of stack
    push(element) {
        this.items.push(element);
        console.log(\`Pushed: \${element}, Stack: [\${this.items}]\`);
    }

    // Remove and return top element
    pop() {
        if (this.isEmpty()) {
            console.log("Stack is empty. Cannot pop.");
            return null;
        }
        const poppedElement = this.items.pop();
        console.log(\`Popped: \${poppedElement}, Stack: [\${this.items}]\`);
        return poppedElement;
    }

    // View top element
    peek() {
        if (this.isEmpty()) {
            console.log("Stack is empty. Cannot peek.");
            return null;
        }
        const topElement = this.items[this.items.length - 1];
        console.log(\`Peek: \${topElement}, Stack: [\${this.items}]\`);
        return topElement;
    }

    // Check if stack is empty
    isEmpty() {
        return this.items.length === 0;
    }

    // Get stack size
    size() {
        const stackSize = this.items.length;
        console.log(\`Size: \${stackSize}\`);
        return stackSize;
    }

    // Clear the stack
    clear() {
        this.items = [];
        console.log("Stack cleared.");
    }
}

const myStack = new Stack();
myStack.push(10);
myStack.push(20);
myStack.push(30);
myStack.peek();
myStack.pop();
myStack.size();
myStack.pop();
myStack.pop();
myStack.pop(); // Try to pop from empty stack
myStack.isEmpty();
                        `
                    }
                ]
            },
            {
                id: 'queues',
                title: 'Queues',
                content: `
                    <h2 class="text-3xl font-bold mb-4 text-gray-800">Queues</h2>
                    <p class="mb-4 text-gray-700 leading-relaxed">
                        A queue is a linear data structure that follows the <strong>FIFO (First-In, First-Out)</strong> principle. This means the first element added to the queue is the first one to be removed.
                        Think of a queue of people waiting for a service: the first person to join the queue is the first person to be served.
                    </p>
                    <h3 class="text-2xl font-semibold mb-3 text-gray-800">Core Operations:</h3>
                    <ul class="list-disc list-inside mb-4 text-gray-700 leading-relaxed space-y-1">
                        <li><strong>Enqueue (or Add/Offer):</strong> Adds an element to the rear (end) of the queue. (O(1))</li>
                        <li><strong>Dequeue (or Remove/Poll):</strong> Removes and returns the element from the front (head) of the queue. (O(1) for linked list, O(n) for naive array or O(1) amortized for circular array/optimized array)</li>
                        <li><strong>Peek (or Front/Element):</strong> Returns the element at the front of the queue without removing it. (O(1))</li>
                        <li><strong>isEmpty:</strong> Checks if the queue is empty. (O(1))</li>
                        <li><strong>isFull (for array-based fixed-size queues):</strong> Checks if the queue is full. (O(1))</li>
                        <li><strong>Size:</strong> Returns the number of elements in the queue. (O(1))</li>
                    </ul>
                    <h3 class="text-2xl font-semibold mb-3 text-gray-800">Implementations:</h3>
                    <p class="mb-4 text-gray-700 leading-relaxed">
                        Queues can be implemented using:
                        <ul class="list-disc list-inside ml-4">
                            <li><strong>Arrays (or Dynamic Arrays/Lists):</strong> Enqueue can be adding to the end (push), dequeue removing from the beginning (shift). 'shift' in JS arrays is O(n). Circular arrays can optimize this.</li>
                            <li><strong>Linked Lists:</strong> Enqueue can be appending to the list (add to tail), dequeue can be removing from the beginning (remove head). This is generally more efficient for dequeue (O(1)).</li>
                        </ul>
                    </p>
                    <h3 class="text-2xl font-semibold mb-3 text-gray-800">Applications:</h3>
                    <ul class="list-disc list-inside mb-4 text-gray-700 leading-relaxed space-y-1">
                        <li>CPU task scheduling.</li>
                        <li>Print job spooling.</li>
                        <li>Breadth-First Search (BFS) algorithm in graphs and trees.</li>
                        <li>Handling requests on a server (e.g., web server request queue).</li>
                        <li>Buffering data (e.g., in streaming).</li>
                        <li>Call center systems.</li>
                    </ul>
                `,
                codeExamples: [
                    {
                        description: 'Queue implementation using an Array (JavaScript built-in methods):',
                        code: `
class Queue {
    constructor() {
        this.items = [];
    }

    // Add element to the rear of the queue
    enqueue(element) {
        this.items.push(element); // Adds to the end
        console.log(\`Enqueued: \${element}, Queue: [\${this.items}]\`);
    }

    // Remove and return element from the front of the queue
    dequeue() {
        if (this.isEmpty()) {
            console.log("Queue is empty. Cannot dequeue.");
            return null;
        }
        const dequeuedElement = this.items.shift(); // Removes from the beginning
        console.log(\`Dequeued: \${dequeuedElement}, Queue: [\${this.items}]\`);
        return dequeuedElement;
    }

    // View the front element
    front() {
        if (this.isEmpty()) {
            console.log("Queue is empty. Cannot see front.");
            return null;
        }
        const frontElement = this.items[0];
        console.log(\`Front: \${frontElement}, Queue: [\${this.items}]\`);
        return frontElement;
    }

    // Check if queue is empty
    isEmpty() {
        return this.items.length === 0;
    }

    // Get queue size
    size() {
        const queueSize = this.items.length;
        console.log(\`Size: \${queueSize}\`);
        return queueSize;
    }

    // Clear the queue
    clear() {
        this.items = [];
        console.log("Queue cleared.");
    }
}

const myQueue = new Queue();
myQueue.enqueue("Task 1");
myQueue.enqueue("Task 2");
myQueue.enqueue("Task 3");
myQueue.front();
myQueue.dequeue();
myQueue.size();
myQueue.dequeue();
myQueue.dequeue();
myQueue.dequeue(); // Try to dequeue from empty queue
myQueue.isEmpty();
                        `
                    }
                ]
            }
        ];

        const topicListEl = document.getElementById('topicList');
        const pageContentEl = document.getElementById('pageContent');
        const terminalOutputEl = document.getElementById('terminalOutput');
        const clearTerminalButton = document.getElementById('clearTerminalButton');
        const sidebar = document.getElementById('sidebar');
        const mainContent = document.getElementById('mainContent');
        const menuButton = document.getElementById('menuButton');

        // Function to execute code and capture console.log output
        function executeAndCaptureOutput(codeString) {
            let output = '';
            const oldLog = console.log;
            const oldError = console.error;
            const oldWarn = console.warn;
            const oldInfo = console.info;

            const appendToOutput = (prefix, ...args) => {
                 output += prefix + args.map(val => {
                    if (typeof val === 'object' && val !== null) {
                        try {
                            return JSON.stringify(val);
                        } catch (e) {
                            return val.toString();
                        }
                    }
                    return String(val);
                }).join(' ') + '\\n';
            };
            
            console.log = (...args) => appendToOutput('', ...args);
            console.error = (...args) => appendToOutput('ERROR: ', ...args);
            console.warn = (...args) => appendToOutput('WARN: ', ...args);
            console.info = (...args) => appendToOutput('INFO: ', ...args);

            try {
                // Prepend class definitions if necessary for examples that use them
                // This is a simplification; a more robust solution would manage scope better.
                let fullCode = codeString;
                if (codeString.includes("new LinkedList()") || codeString.includes("new Node(")) {
                    fullCode = `
                        class Node { constructor(data) { this.data = data; this.next = null; } }
                        class LinkedList { 
                            constructor() { this.head = null; }
                            append(data) { const newNode = new Node(data); if (!this.head) { this.head = newNode; return; } let current = this.head; while (current.next) { current = current.next; } current.next = newNode; }
                            prepend(data) { const newNode = new Node(data); newNode.next = this.head; this.head = newNode; }
                            printList() { let current = this.head; const elements = []; while (current) { elements.push(current.data); current = current.next; } console.log(elements.join(" -> ")); }
                        }
                    ` + codeString;
                }
                 if (codeString.includes("new Stack()")) {
                    fullCode = `
                        class Stack {
                            constructor() { this.items = []; }
                            push(element) { this.items.push(element); console.log(\`Pushed: \${element}, Stack: [\${this.items}]\`); }
                            pop() { if (this.isEmpty()) { console.log("Stack is empty. Cannot pop."); return null; } const poppedElement = this.items.pop(); console.log(\`Popped: \${poppedElement}, Stack: [\${this.items}]\`); return poppedElement; }
                            peek() { if (this.isEmpty()) { console.log("Stack is empty. Cannot peek."); return null; } const topElement = this.items[this.items.length - 1]; console.log(\`Peek: \${topElement}, Stack: [\${this.items}]\`); return topElement; }
                            isEmpty() { return this.items.length === 0; }
                            size() { const stackSize = this.items.length; console.log(\`Size: \${stackSize}\`); return stackSize; }
                            clear() { this.items = []; console.log("Stack cleared."); }
                        }
                    ` + codeString;
                }
                if (codeString.includes("new Queue()")) {
                     fullCode = `
                        class Queue {
                            constructor() { this.items = []; }
                            enqueue(element) { this.items.push(element); console.log(\`Enqueued: \${element}, Queue: [\${this.items}]\`); }
                            dequeue() { if (this.isEmpty()) { console.log("Queue is empty. Cannot dequeue."); return null; } const dequeuedElement = this.items.shift(); console.log(\`Dequeued: \${dequeuedElement}, Queue: [\${this.items}]\`); return dequeuedElement; }
                            front() { if (this.isEmpty()) { console.log("Queue is empty. Cannot see front."); return null; } const frontElement = this.items[0]; console.log(\`Front: \${frontElement}, Queue: [\${this.items}]\`); return frontElement; }
                            isEmpty() { return this.items.length === 0; }
                            size() { const queueSize = this.items.length; console.log(\`Size: \${queueSize}\`); return queueSize; }
                            clear() { this.items = []; console.log("Queue cleared."); }
                        }
                    ` + codeString;
                }


                eval(fullCode);
            } catch (e) {
                output += 'RUNTIME ERROR: ' + e.message + '\\n';
                output += 'Stack: ' + e.stack + '\\n';
            }
            
            console.log = oldLog;
            console.error = oldError;
            console.warn = oldWarn;
            console.info = oldInfo;
            return output.trim();
        }

        // Function to display content for a topic
        function showTopic(topicId) {
            const allSections = pageContentEl.querySelectorAll('.content-section');
            allSections.forEach(section => section.classList.remove('active'));

            const activeSection = pageContentEl.querySelector(`#section-${topicId}`);
            if (activeSection) {
                activeSection.classList.add('active');
            }

            // Update active link in sidebar
            const allLinks = topicListEl.querySelectorAll('a');
            allLinks.forEach(link => link.classList.remove('bg-gray-700', 'text-white'));
            const activeLink = topicListEl.querySelector(`a[data-topic-id="${topicId}"]`);
            if (activeLink) {
                activeLink.classList.add('bg-gray-700', 'text-white');
            }
             // For mobile: hide sidebar after selection
            if (window.innerWidth <= 768) {
                sidebar.classList.add('sidebar-hidden');
                sidebar.classList.remove('sidebar-visible');
                mainContent.classList.remove('main-content-full'); // Ensure main content is not full width when sidebar is programmatically hidden
            }
        }
        
        // Populate sidebar and content sections
        dsaCourse.forEach((topic, index) => {
            // Add to sidebar
            const listItem = document.createElement('li');
            const link = document.createElement('a');
            link.href = '#';
            link.textContent = topic.title;
            link.dataset.topicId = topic.id;
            link.className = 'block py-2 px-3 rounded-md hover:bg-gray-700 hover:text-white transition-colors';
            link.onclick = (e) => {
                e.preventDefault();
                showTopic(topic.id);
            };
            listItem.appendChild(link);
            topicListEl.appendChild(listItem);

            // Create content section
            const sectionDiv = document.createElement('div');
            sectionDiv.id = `section-${topic.id}`;
            sectionDiv.className = 'content-section p-4 md:p-6 bg-white rounded-lg shadow-md';
            
            let contentHTML = topic.content; // HTML content from dsaCourse

            if (topic.codeExamples && topic.codeExamples.length > 0) {
                contentHTML += `<h3 class="text-2xl font-semibold mt-6 mb-3 text-gray-800">Code Examples:</h3>`;
                topic.codeExamples.forEach((example, exIndex) => {
                    const exampleId = `${topic.id}-example-${exIndex}`;
                    contentHTML += `
                        <div class="mb-6 p-4 border border-gray-200 rounded-lg bg-gray-50">
                            <p class="mb-2 text-gray-700 font-medium">${example.description}</p>
                            <pre class="code-block"><code>${example.code.trim()}</code></pre>
                            <button 
                                class="mt-2 px-4 py-2 bg-blue-500 text-white rounded-lg hover:bg-blue-600 transition-colors focus:outline-none focus:ring-2 focus:ring-blue-300"
                                onclick="runCodeSnippet('${topic.id}', ${exIndex})">
                                Run Code
                            </button>
                        </div>
                    `;
                });
            }
            sectionDiv.innerHTML = contentHTML;
            pageContentEl.appendChild(sectionDiv);
        });

        // Function to run code snippet and display in terminal
        window.runCodeSnippet = function(topicId, exampleIndex) {
            const topic = dsaCourse.find(t => t.id === topicId);
            if (!topic || !topic.codeExamples[exampleIndex]) return;

            const codeToRun = topic.codeExamples[exampleIndex].code;
            const output = executeAndCaptureOutput(codeToRun);

            const prompt = `<span class="terminal-prompt">user@dsalearner:~$</span> run ./example.js\n`;
            const codeHeader = `// --- Code Snippet ---\n`;
            const outputHeader = `\n// --- Output ---\n`;
            
            terminalOutputEl.innerHTML += `<div>${prompt}${codeHeader}<span class="text-cyan-400">${codeToRun.trim()}</span>${outputHeader}<span class="text-gray-300">${output}</span>\n</div>`;
            terminalOutputEl.scrollTop = terminalOutputEl.scrollHeight; // Scroll to bottom
        }

        // Clear terminal button
        clearTerminalButton.addEventListener('click', () => {
            terminalOutputEl.innerHTML = 'Terminal cleared.\n';
        });

        // Mobile menu toggle
        menuButton.addEventListener('click', () => {
            sidebar.classList.toggle('sidebar-hidden');
            sidebar.classList.toggle('sidebar-visible');
             // Adjust main content margin if sidebar is visible
            if (sidebar.classList.contains('sidebar-visible')) {
                mainContent.classList.add('main-content-full'); // This might seem counterintuitive name-wise
            } else {
                mainContent.classList.remove('main-content-full');
            }
        });
        
        // Close sidebar when clicking outside on mobile
        mainContent.addEventListener('click', () => {
            if (window.innerWidth <= 768 && sidebar.classList.contains('sidebar-visible')) {
                sidebar.classList.add('sidebar-hidden');
                sidebar.classList.remove('sidebar-visible');
                mainContent.classList.remove('main-content-full');
            }
        });


        // Show the first topic by default
        if (dsaCourse.length > 0) {
            showTopic(dsaCourse[0].id);
        }

    </script>
</body>
</html>
