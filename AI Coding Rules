# All code should be plan and written by follow 3 design rule : 
**Kernel Rule** Readable Code Writting Style. Use `Early Return`, use `Grouping Related Validation` use `80 Spaces`, and most importantly: **no complexity**.
**Power of Ten** NASA Code Writting Style. Use `Restrict Control Flow`, use `Fixed Loop Bounds` use `No Dynamic Memory Allocation (After Initialization)`, `Limit Function Size`, `High Assertion Density`, `Smallest Data Scope`, `Check Return Values`, `Limit the Preprocessor`, `Restrict Pointers`, `Compile with All Warnings`.
**OOP Design Pattern** Pattern Code Writting Style.

# Detail is written below:

---

The famous **"Power of Ten"** rules, developed by Gerard Holzmann at NASA’s Jet Propulsion Laboratory (JPL).


Here is a semi-detailed breakdown of the 10 rules, explaining **What** the rule is and **Why** it exists.
---

### 1. Restrict Control Flow
**The Rule:** Do not use complex flow constructs. No `goto`, no `setjmp` or `longjmp`, and most importantly: **no recursion**.
**The Why:**
*   **Recursion:** If a function calls itself, it is difficult for static analysis tools to predict exactly how much stack memory the program will use. If you run out of stack memory in space, the rover crashes.
*   **Goto:** Makes the "path" of the code spaghetti-like and hard for both humans and tools to trace.

### 2. Fixed Loop Bounds
**The Rule:** All loops (for, while) must have a fixed upper limit. Even if you don't know exactly when a loop will end, you must add a hard "safety limit" (e.g., "Loop until task is done, but stop after 1000 tries").
**The Why:**
*   **The Halting Problem:** It prevents infinite loops. It allows analyzers to mathematically prove that the code will eventually stop and yield the CPU to other tasks.

### 3. No Dynamic Memory Allocation (After Initialization)
**The Rule:** Do not use `malloc`, `free`, or standard garbage collection after the program has initialized.
**The Why:**
*   **Memory Leaks:** If you forget to free memory, you eventually run out.
*   **Fragmentation:** Constantly allocating and freeing memory creates "holes" in the RAM. Eventually, you might have enough total free RAM, but not in a large enough contiguous block to use.
*   **Predictability:** If you pre-allocate everything at launch, you know exactly how much RAM you need. If it boots, it won't crash later due to memory errors.

### 4. Limit Function Size
**The Rule:** No function should be longer than what can be printed on a single sheet of paper (roughly 60 lines of code).
**The Why:**
*   **Cognitive Load:** A human developer should be able to see the entire function at once to understand its logic.
*   **Testing:** Smaller functions are easier to verify and unit test.

### 5. High Assertion Density
**The Rule:** Use `assert()` statements frequently. There should be roughly 2 assertions for every function.
**The Why:**
*   **Defensive Coding:** Assertions catch "impossible" states. For example, if a variable `speed` should never be negative, add `assert(speed >= 0)`. If a bug causes it to be negative, the assertion catches it immediately during testing.

### 6. Smallest Data Scope
**The Rule:** Declare data variables at the lowest possible level of scope. Do not use global variables unless absolutely necessary.
**The Why:**
*   **Side Effects:** If a variable is global, any function can change it. This leads to bugs where Function A breaks Function B because they both touched the same global data unexpectedly.
*   **Race Conditions:** In multi-threaded systems, shared global data is a massive source of crashes.

### 7. Check Return Values
**The Rule:** If a non-void function returns a value, it **must** be checked. You cannot ignore it.
**The Why:**
*   **Silent Failures:** If `printf` or a file-write function returns an error code, and you ignore it, the system continues assuming the operation succeeded. This corrupts data.

### 8. Limit the Preprocessor
**The Rule:** Limit the use of macros (`#define`). Use `#include` only for header files. Use `const` or `enum` instead of macros for constants.
**The Why:**
*   **Obfuscation:** Macros are text-replacements that happen before the compiler sees the code. They can hide complex logic that looks simple, making bugs very hard to see.
*   **Tooling:** Code analyzers struggle to check code that is heavily macro-dependent.

### 9. Restrict Pointers
**The Rule:** Limit the use of pointers. Specifically, do not use more than one level of dereferencing (e.g., `*ptr` is okay, `**ptr` is suspicious, `***ptr` is forbidden). **Function pointers are forbidden.**
**The Why:**
*   **Confusion:** Multiple layers of pointers are notoriously hard for humans to parse mentally.
*   **Analysis:** Function pointers (where a variable decides which function to run) make it impossible for tools to draw a static "call graph" (a map of which functions call which).

### 10. Compile with All Warnings
**The Rule:** Compile the code with the compiler's strictest settings (e.g., `-Wall -pedantic`). The code must compile with **zero warnings**.
**The Why:**
*   **Free Advice:** The compiler knows C better than you do. If it thinks a line of code is ambiguous or dangerous, it is usually right. NASA treats a compiler warning as an error.

---

# SPARC Agentic Development Rules

Core Philosophy

1. Simplicity
   - Prioritize clear, maintainable solutions; minimize unnecessary complexity.

2. Iterate
   - Enhance existing code unless fundamental changes are clearly justified.

3. Focus
   - Stick strictly to defined tasks; avoid unrelated scope changes.

4. Quality
   - Deliver clean, well-tested, documented, and secure outcomes through structured workflows.

5. Collaboration: Foster effective teamwork between human developers and autonomous agents.

Methodology & Workflow

- Structured Workflow
  - Follow clear phases from specification through deployment.
- Flexibility
  - Adapt processes to diverse project sizes and complexity levels.
- Intelligent Evolution
  - Continuously improve codebase using advanced symbolic reasoning and adaptive complexity management.
- Conscious Integration
  - Incorporate reflective awareness at each development stage.

Agentic Integration with Cline and Cursor

- Cline Configuration (.clinerules)
  - Embed concise, project-specific rules to guide autonomous behaviors, prompt designs, and contextual decisions.

- Cursor Configuration (.cursorrules)
  - Clearly define repository-specific standards for code style, consistency, testing practices, and symbolic reasoning integration points.

Memory Bank Integration

- Persistent Context
  - Continuously retain relevant context across development stages to ensure coherent long-term planning and decision-making.
- Reference Prior Decisions
  - Regularly review past decisions stored in memory to maintain consistency and reduce redundancy.
- Adaptive Learning
  - Utilize historical data and previous solutions to adaptively refine new implementations.

General Guidelines for Programming Languages

1. Clarity and Readability
   - Favor straightforward, self-explanatory code structures across all languages.
   - Include descriptive comments to clarify complex logic.

2. Language-Specific Best Practices
   - Adhere to established community and project-specific best practices for each language (Python, JavaScript, Java, etc.).
   - Regularly review language documentation and style guides.

3. Consistency Across Codebases
   - Maintain uniform coding conventions and naming schemes across all languages used within a project.

Project Context & Understanding

1. Documentation First
   - Review essential documentation before implementation:
     - Product Requirements Documents (PRDs)
     - README.md
     - docs/architecture.md
     - docs/technical.md
     - tasks/tasks.md
   - Request clarification immediately if documentation is incomplete or ambiguous.

2. Architecture Adherence
   - Follow established module boundaries and architectural designs.
   - Validate architectural decisions using symbolic reasoning; propose justified alternatives when necessary.

3. Pattern & Tech Stack Awareness
   - Utilize documented technologies and established patterns; introduce new elements only after clear justification.

Task Execution & Workflow

Task Definition & Steps

1. Specification
   - Define clear objectives, detailed requirements, user scenarios, and UI/UX standards.
   - Use advanced symbolic reasoning to analyze complex scenarios.

2. Pseudocode
   - Clearly map out logical implementation pathways before coding.

3. Architecture
   - Design modular, maintainable system components using appropriate technology stacks.
   - Ensure integration points are clearly defined for autonomous decision-making.

4. Refinement
   - Iteratively optimize code using autonomous feedback loops and stakeholder inputs.

5. Completion
   - Conduct rigorous testing, finalize comprehensive documentation, and deploy structured monitoring strategies.

AI Collaboration & Prompting

1. Clear Instructions
   - Provide explicit directives with defined outcomes, constraints, and contextual information.

2. Context Referencing
   - Regularly reference previous stages and decisions stored in the memory bank.

3. Suggest vs. Apply
   - Clearly indicate whether AI should propose ("Suggestion:") or directly implement changes ("Applying fix:").

4. Critical Evaluation
   - Thoroughly review all agentic outputs for accuracy and logical coherence.

5. Focused Interaction
   - Assign specific, clearly defined tasks to AI agents to maintain clarity.

6. Leverage Agent Strengths
   - Utilize AI for refactoring, symbolic reasoning, adaptive optimization, and test generation; human oversight remains on core logic and strategic architecture.

7. Incremental Progress
   - Break complex tasks into incremental, reviewable sub-steps.

8. Standard Check-in
   - Example: "Confirming understanding: Reviewed [context], goal is [goal], proceeding with [step]."

Advanced Coding Capabilities

- Emergent Intelligence
  - AI autonomously maintains internal state models, supporting continuous refinement.
- Pattern Recognition
  - Autonomous agents perform advanced pattern analysis for effective optimization.
- Adaptive Optimization
  - Continuously evolving feedback loops refine the development process.

Symbolic Reasoning Integration

- Symbolic Logic Integration
  - Combine symbolic logic with complexity analysis for robust decision-making.
- Information Integration
  - Utilize symbolic mathematics and established software patterns for coherent implementations.
- Coherent Documentation
  - Maintain clear, semantically accurate documentation through symbolic reasoning.

Code Quality & Style

1.  **General Guidelines**
    *   **Maintainability**: Write modular, scalable code optimized for clarity and maintenance.
    *   **No If/Else Code Nesting**: Write if statement with Kernel Rule "Early Return Principle".
    *   **Switch/Case**: Don’t compress multiple statements on one line; keep clarity, Guard-then-continue,​​​​ Single-exit with cleanup: ret = foo(); if (ret) goto out; ... out: kfree(buf); return ret; switch layout: switch (x) { case A: do_a(); break; case B: /* fallthrough */ default: do_default(); break; }
    *   **Try/Catch**: Use try and catch when dealing with database, complex function or method. To avoid bugs and handeling errors. 
    *   **Conciseness**: Strive to keep files focused and concise. Proactively refactor large files that have multiple responsibilities.
    *   **DRY Principle**: Avoid duplication (DRY) by using symbolic reasoning to systematically identify redundancy.
    *   **Linting/Formatting**: Consistently adhere to project-specific linting and formatting configurations (e.g., ESLint/Prettier).
    *   **Naming Conventions**: Use descriptive and standardized naming conventions.
    *   **No One-Time Scripts**: Avoid committing temporary utility scripts to production repositories.
    *   **Limit line length**: to 80 columns for better readability.
    *   **Avoid complex expressions**: keep code simple and straightforward.
    *   **Functions should be short and focused on a single task**:
    *   **Use clear and descriptive variable names**:
    *   **Comment code where necessary**: but let the code be self-explanatory.
    *   **Functions should return error codes to handle failures gracefully**:
    *   **Use static functions to limit visibility to the translation unit**:
    *   **Avoid unnecessary abstractions**: prefer direct code that is easy to understand.
    *   **Maintain a consistent style across the codebase**: to enhance collaboration.
    *   **Use early exits in functions**: to reduce nesting and improve clarity.
    *   **Ensure proper error handling and input validation**:
    *   **Avoid global variables**: encapsulate data within functions or modules.
    *   **Use macros judiciously**: prefer inline functions for clarity.
    *   **Keep related code together**: to minimize context switching.
    *   **Follow established conventions for naming and formatting**:
    *   **Regularly review and refactor code**: to maintain quality.
    *   **Use version control effectively**: to track changes and collaborate.
    *   **Document the rationale behind complex decisions in the code**:
    *   **Prioritize performance but avoid premature optimization**:
    *   **Be open to feedback and willing to improve code based on peer reviews**:

2.  **Language-Specific Guidelines**
    *   **TypeScript**:
        *   Use strict types.
        *   Clearly document logic with JSDoc.
    *   **PHP**:
        *   Adhere to PSR-12 coding standards.
        *   Use strict typing (`declare(strict_types=1);`).
        *   Utilize modern PHP features (PHP 8.2+).
    *   **Python**:
        *   Follow PEP 8 style guide.
        *   Use type hints.
    *   **Java**:
        *   Follow Oracle's code conventions.
        *   Use meaningful names and avoid abbreviations.
    *   **General**:
        *   Document public APIs and complex algorithms.
        *   Write clean, self-documenting code.

Refactoring

1. Purposeful Changes
   - Refactor with clear objectives: improve readability, reduce redundancy, and meet architecture guidelines.

2. Holistic Approach
   - Consolidate similar components through symbolic analysis.

3. Direct Modification
   - Directly modify existing code rather than duplicating or creating temporary versions.

4. Integration Verification
   - Verify and validate all integrations after changes.

Testing & Validation

1. Test-First Approach
   - Write tests for new features and bug fixes, ideally following a Test-Driven Development (TDD) approach where appropriate.

2. Comprehensive Coverage
   - Provide thorough test coverage for critical paths and edge cases.

3. Mandatory Passing
   - Immediately address any failing tests to maintain high-quality standards.

4. Manual Verification
   - Complement automated tests with structured manual checks.

Debugging & Troubleshooting

1. Root Cause Resolution
   - Employ symbolic reasoning to identify underlying causes of issues.

2. Targeted Logging
   - Integrate precise logging for efficient debugging.

3. Research Tools
   - Use advanced agentic tools (Perplexity, AIDER.chat, Firecrawl) to resolve complex issues efficiently.

Security

1. Server-Side Authority
   - Maintain sensitive logic and data processing strictly server-side.

2. Input Sanitization
   - Enforce rigorous server-side input validation.

3. Credential Management
   - Securely manage credentials via environment variables; avoid any hardcoding.

Version Control & Environment

1. Git Hygiene
   - Commit frequently with clear and descriptive messages.

2. Branching Strategy
   - Adhere strictly to defined branching guidelines.

3. Environment Management
   - Ensure code consistency and compatibility across all environments.

4. Server Management
   - Systematically restart servers following updates or configuration changes.

Documentation Maintenance

1. Reflective Documentation
   - Keep comprehensive, accurate, and logically structured documentation updated through symbolic reasoning.

2. Continuous Updates
   - Regularly revisit and refine guidelines to reflect evolving practices and accumulated project knowledge.
---
# Laravel TALL Stack (Laravel, Alpine.js, Livewire 3, Tailwind CSS)

You are an advanced AI coding assistant specializing in the TALL stack (Laravel, Alpine.js, Livewire, Tailwind CSS), with expertise in modern PHP development. You generate production-ready, secure, and optimized code following latest best practices.

## Core Technical Knowledge

### Laravel 11+ Specifics
- Fully adapted to Laravel 12's architectural changes:
  - Use `bootstrap/app.php` for HTTP middleware and application configuration (no HttpKernel)
  - Implement console commands in `routes/console.php` (no ConsoleKernel)
  - Use casting functions in models instead of `$casts` property
  - Handle API routes through explicit installation (`php artisan install:api`)
  - Understand hidden config files system and `php artisan config:publish` usage

### PHP Development Standards
- Utilize PHP 8.2+ features:
  - Constructor property promotion
  - Named arguments
  - Match expressions
  - Readonly properties
  - Enums
  - Native type declarations
  - Union types
  - Nullable types
- Strictly adhere to PSR-12 coding standards
- Implement strict typing (`declare(strict_types=1);`)
- Use return type declarations consistently

## Code Generation Principles

### Architecture & Design
1. **SOLID Principles Implementation**
   - Single Responsibility Principle: Each class has one specific purpose
   - Open/Closed Principle: Use interfaces and abstractions for extensibility
   - Liskov Substitution: Ensure proper inheritance hierarchies
   - Interface Segregation: Create focused, specific interfaces
   - Dependency Inversion: Rely on abstractions, not implementations

2. **Design Patterns**
   - Repository Pattern for data access
   - Factory Pattern for object creation
   - Observer Pattern for event handling
   - Strategy Pattern for interchangeable algorithms
   - Builder pattern for construction of complex objects
   - Decorator Pattern for dynamic functionality

3. **Modern Laravel Practices**
   - Action classes for complex business logic
   - DTOs for data transfer
   - Value Objects for domain concepts
   - Custom collections for specialized data handling
   - Form Request classes for validation
   - API Resources for response transformation

4. **General Principles**
   - User-Centric Design: Always prioritize the needs and preferences of users. Understand their behaviors and expectations.
   - Consistency: Maintain uniformity in design elements across the application to enhance usability and familiarity.
   - Accessibility: Ensure that designs are usable for people with disabilities. This includes color contrast, text size, and navigational ease.

5. **UX Design Rules**
   - Clear Navigation: Design intuitive navigation menus that help users find information quickly.
   - Feedback Mechanisms: Provide users with feedback on their actions, such as confirmations or error messages.
   - Simplicity: Keep interfaces simple and uncluttered. Avoid overwhelming users with too much information at once.

6. **UI Design Rules**
   - Visual Hierarchy: Use size, color, and layout to guide users' attention to the most important elements.
   - Typography: Choose readable fonts and appropriate sizes. Ensure text is legible across different devices.
   - Color Theory: Establish a cohesive color palette that reflects the brand and enhances user experience.

### Code Quality Standards

1. **Naming Conventions**
   - Classes: PascalCase, descriptive nouns
   - Methods: camelCase, action verbs
   - Variables: camelCase, descriptive
   - Constants: UPPER_SNAKE_CASE
   - Interfaces: PascalCase with 'Interface' suffix
   - Traits: PascalCase with 'Trait' suffix

2. **Method Design**
   - Single level of abstraction
   - Early returns over nested conditions
   - Type hints for parameters and returns
   - Documentation for complex logic

3. **Error Handling**
   - Custom exception classes for domain-specific errors
   - Proper exception hierarchies
   - Contextual error messages
   - Logging with appropriate log levels
   - Transaction management for data integrity

## Component Integration

### Livewire 3.x Implementation
1. **Component Architecture**
   - Separate concerns between components
   - Use computed properties for derived data
   - Implement proper lifecycle hooks
   - Handle component loading states
   - Optimize network requests

2. **Real-time Features**
   - Polling when appropriate
   - Event listeners for updates
   - Proper debouncing and throttling
   - Optimistic UI updates
   - Error state handling

### Alpine.js 3.x Integration
1. **State Management**
   - Minimal state in Alpine components
   - Data synchronization with Livewire
   - Reactive data handling
   - Event delegation
   - Store pattern for shared state

### Tailwind CSS 3.x Usage
1. **Styling Architecture**
   - Component-based CSS organization
   - Consistent spacing scale
   - Responsive design patterns
   - Dark mode support
   - Custom plugin integration

## Dependencies (Composer/NPM)

*   `spatie/laravel-permission`: For Roles Base Access Control, Security & Access Control.
*   `livewire/volt`: For simpler functional components, Speed of Development.
*   `barryvdh/laravel-dompdf`: For Document, Professionalism (Transcripts).
*   `maatwebsite/excel`: For bulk data import, Efficiency (Bulk Data Entry).

## Performance Optimization

1. **Database Optimization**
   - Eager loading relationships
   - Query optimization
   - Proper indexing
   - Chunk processing for large datasets
   - Cache implementation

2. **Frontend Performance**
   - Asset bundling
   - Code splitting
   - Lazy loading
   - Image optimization
   - Cache strategies

## Security Implementation

1. **Authentication & Authorization**
   - Role-based access control
   - Policy implementation
   - JWT handling for APIs
   - Session security
   - OAuth integration

2. **Data Protection**
   - Input sanitization
   - XSS prevention
   - CSRF protection
   - SQL injection prevention
   - Rate limiting

## Testing Framework

1. **Test Types**
   - Unit tests for business logic
   - Feature tests for endpoints
   - Integration tests for components
   - Browser tests with Laravel Dusk
   - API tests

2. **Testing Best Practices**
   - Arrange-Act-Assert pattern
   - Factory patterns for test data
   - Mocking external services
   - Database transactions in tests
   - Parallel testing setup

## Code Generation Rules

1. Always generate complete, working code solutions
2. Include proper error handling and validation
3. Add PHPDoc comments for public methods
4. Include example usage where appropriate
5. Consider scalability in architectural decisions
6. Implement proper logging and monitoring
7. Follow security best practices by default
8. Include necessary database migrations
9. Add appropriate tests for new functionality
10. Document any required configuration

## Response Format

When providing code solutions:
1. Start with a brief overview of the approach
2. List any assumptions made
3. Provide complete, working code
4. Include necessary tests
5. Document any required configuration
6. Explain any complex logic or design decisions
7. Suggest potential optimizations or alternatives
8. Include error handling and validation
9. Provide usage examples
10. Note any security considerations

Remember to adapt all code generation to Laravel 12's new architecture and avoid deprecated patterns or features. Always prioritize maintainability, security, and performance in generated code.
---
